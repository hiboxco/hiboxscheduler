{"version":3,"file":"react-easy-crop.min.js","sources":["../../src/helpers.ts","../../src/index.tsx"],"sourcesContent":["import { Area, MediaSize, Point, Size } from './types'\n\n/**\n * Compute the dimension of the crop area based on media size,\n * aspect ratio and optionally rotation\n */\nexport function getCropSize(\n  mediaWidth: number,\n  mediaHeight: number,\n  containerWidth: number,\n  containerHeight: number,\n  aspect: number,\n  rotation = 0\n): Size {\n  const { width, height } = translateSize(mediaWidth, mediaHeight, rotation)\n  const fittingWidth = Math.min(width, containerWidth)\n  const fittingHeight = Math.min(height, containerHeight)\n\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight,\n    }\n  }\n\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect,\n  }\n}\n\n/**\n * Ensure a new media position stays in the crop area.\n */\nexport function restrictPosition(\n  position: Point,\n  mediaSize: Size,\n  cropSize: Size,\n  zoom: number,\n  rotation = 0\n): Point {\n  const { width, height } = translateSize(mediaSize.width, mediaSize.height, rotation)\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom),\n  }\n}\n\nfunction restrictPositionCoord(\n  position: number,\n  mediaSize: number,\n  cropSize: number,\n  zoom: number\n): number {\n  const maxPosition = (mediaSize * zoom) / 2 - cropSize / 2\n  return Math.min(maxPosition, Math.max(position, -maxPosition))\n}\n\nexport function getDistanceBetweenPoints(pointA: Point, pointB: Point) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2))\n}\n\nexport function getRotationBetweenPoints(pointA: Point, pointB: Point) {\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI\n}\n\n/**\n * Compute the output cropped area of the media in percentages and pixels.\n * x/y are the top-left coordinates on the src media\n */\nexport function computeCroppedArea(\n  crop: Point,\n  mediaSize: MediaSize,\n  cropSize: Size,\n  aspect: number,\n  zoom: number,\n  rotation = 0,\n  restrictPosition = true\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  const limitAreaFn = restrictPosition && rotation === 0 ? limitArea : noOp\n  const croppedAreaPercentages = {\n    x: limitAreaFn(\n      100,\n      (((mediaSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaSize.width) * 100\n    ),\n    y: limitAreaFn(\n      100,\n      (((mediaSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaSize.height) * 100\n    ),\n    width: limitAreaFn(100, ((cropSize.width / mediaSize.width) * 100) / zoom),\n    height: limitAreaFn(100, ((cropSize.height / mediaSize.height) * 100) / zoom),\n  }\n\n  // we compute the pixels size naively\n  const widthInPixels = Math.round(\n    limitAreaFn(\n      mediaSize.naturalWidth,\n      (croppedAreaPercentages.width * mediaSize.naturalWidth) / 100\n    )\n  )\n  const heightInPixels = Math.round(\n    limitAreaFn(\n      mediaSize.naturalHeight,\n      (croppedAreaPercentages.height * mediaSize.naturalHeight) / 100\n    )\n  )\n  const isImgWiderThanHigh = mediaSize.naturalWidth >= mediaSize.naturalHeight * aspect\n\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to iamge height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  const sizePixels = isImgWiderThanHigh\n    ? {\n        width: Math.round(heightInPixels * aspect),\n        height: heightInPixels,\n      }\n    : {\n        width: widthInPixels,\n        height: Math.round(widthInPixels / aspect),\n      }\n  const croppedAreaPixels = {\n    ...sizePixels,\n    x: Math.round(\n      limitAreaFn(\n        mediaSize.naturalWidth - sizePixels.width,\n        (croppedAreaPercentages.x * mediaSize.naturalWidth) / 100\n      )\n    ),\n    y: Math.round(\n      limitAreaFn(\n        mediaSize.naturalHeight - sizePixels.height,\n        (croppedAreaPercentages.y * mediaSize.naturalHeight) / 100\n      )\n    ),\n  }\n  return { croppedAreaPercentages, croppedAreaPixels }\n}\n\n/**\n * Ensure the returned value is between 0 and max\n */\nfunction limitArea(max: number, value: number): number {\n  return Math.min(max, Math.max(0, value))\n}\n\nfunction noOp(_max: number, value: number) {\n  return value\n}\n\n/**\n * Compute the crop and zoom from the croppedAreaPixels\n */\nfunction getZoomFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize?: Size\n): number {\n  const mediaZoom = mediaSize.width / mediaSize.naturalWidth\n\n  if (cropSize) {\n    const isHeightMaxSize = cropSize.height > cropSize.width\n    return isHeightMaxSize\n      ? cropSize.height / mediaZoom / croppedAreaPixels.height\n      : cropSize.width / mediaZoom / croppedAreaPixels.width\n  }\n\n  const aspect = croppedAreaPixels.width / croppedAreaPixels.height\n  const isHeightMaxSize = mediaSize.naturalWidth >= mediaSize.naturalHeight * aspect\n  return isHeightMaxSize\n    ? mediaSize.naturalHeight / croppedAreaPixels.height\n    : mediaSize.naturalWidth / croppedAreaPixels.width\n}\n\n/**\n * Compute the crop and zoom from the croppedAreaPixels\n */\nexport function getInitialCropFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize?: Size\n): { crop: Point; zoom: number } {\n  const mediaZoom = mediaSize.width / mediaSize.naturalWidth\n\n  const zoom = getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize)\n\n  const cropZoom = mediaZoom * zoom\n\n  const crop = {\n    x: ((mediaSize.naturalWidth - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y: ((mediaSize.naturalHeight - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom,\n  }\n  return { crop, zoom }\n}\n\n/**\n * Return the point that is the center of point a and b\n */\nexport function getCenter(a: Point, b: Point): Point {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2,\n  }\n}\n\n/**\n *\n * Returns an x,y point once rotated around xMid,yMid\n */\nexport function rotateAroundMidPoint(\n  x: number,\n  y: number,\n  xMid: number,\n  yMid: number,\n  degrees: number\n): [number, number] {\n  const cos = Math.cos\n  const sin = Math.sin\n  const radian = (degrees * Math.PI) / 180 // Convert to radians\n  // Subtract midpoints, so that midpoint is translated to origin\n  // and add it in the end again\n  const xr = (x - xMid) * cos(radian) - (y - yMid) * sin(radian) + xMid\n  const yr = (x - xMid) * sin(radian) + (y - yMid) * cos(radian) + yMid\n\n  return [xr, yr]\n}\n\n/**\n * Returns the new bounding area of a rotated rectangle.\n */\nexport function translateSize(width: number, height: number, rotation: number): Size {\n  const centerX = width / 2\n  const centerY = height / 2\n\n  const outerBounds = [\n    rotateAroundMidPoint(0, 0, centerX, centerY, rotation),\n    rotateAroundMidPoint(width, 0, centerX, centerY, rotation),\n    rotateAroundMidPoint(width, height, centerX, centerY, rotation),\n    rotateAroundMidPoint(0, height, centerX, centerY, rotation),\n  ]\n\n  const minX = Math.min(...outerBounds.map(p => p[0]))\n  const maxX = Math.max(...outerBounds.map(p => p[0]))\n  const minY = Math.min(...outerBounds.map(p => p[1]))\n  const maxY = Math.max(...outerBounds.map(p => p[1]))\n\n  return { width: maxX - minX, height: maxY - minY }\n}\n\n/**\n * Combine multiple class names into a single string.\n */\nexport function classNames(...args: (boolean | string | number | undefined | void | null)[]) {\n  return args\n    .filter(value => {\n      if (typeof value === 'string' && value.length > 0) {\n        return true\n      }\n\n      return false\n    })\n    .join(' ')\n    .trim()\n}\n","import React from 'react'\nimport normalizeWheel from 'normalize-wheel'\nimport { Area, MediaSize, Point, Size, VideoSrc } from './types'\nimport {\n  getCropSize,\n  restrictPosition,\n  getDistanceBetweenPoints,\n  getRotationBetweenPoints,\n  computeCroppedArea,\n  getCenter,\n  getInitialCropFromCroppedAreaPixels,\n  classNames,\n} from './helpers'\nimport cssStyles from './styles.css'\n\nexport type CropperProps = {\n  image?: string\n  video?: string | VideoSrc[]\n  transform?: string\n  crop: Point\n  zoom: number\n  rotation: number\n  aspect: number\n  minZoom: number\n  maxZoom: number\n  cropShape: 'rect' | 'round'\n  cropSize?: Size\n  objectFit?: 'contain' | 'horizontal-cover' | 'vertical-cover'\n  showGrid?: boolean\n  zoomSpeed: number\n  zoomWithScroll?: boolean\n  onCropChange: (location: Point) => void\n  onZoomChange?: (zoom: number) => void\n  onRotationChange?: (rotation: number) => void\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropAreaChange?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropSizeChange?: (cropSize: Size) => void\n  onInteractionStart?: () => void\n  onInteractionEnd?: () => void\n  onMediaLoaded?: (mediaSize: MediaSize) => void\n  style: {\n    containerStyle?: React.CSSProperties\n    mediaStyle?: React.CSSProperties\n    cropAreaStyle?: React.CSSProperties\n  }\n  classes: {\n    containerClassName?: string\n    mediaClassName?: string\n    cropAreaClassName?: string\n  }\n  restrictPosition: boolean\n  initialCroppedAreaPixels?: Area\n  mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>\n  disableAutomaticStylesInjection?: boolean\n}\n\ntype State = {\n  cropSize: Size | null\n  hasWheelJustStarted: boolean\n}\n\nconst MIN_ZOOM = 1\nconst MAX_ZOOM = 3\n\nclass Cropper extends React.Component<CropperProps, State> {\n  static defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect',\n    objectFit: 'contain',\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true,\n  }\n\n  imageRef: HTMLImageElement | null = null\n  videoRef: HTMLVideoElement | null = null\n  containerRef: HTMLDivElement | null = null\n  styleRef: HTMLStyleElement | null = null\n  containerRect: DOMRect | null = null\n  mediaSize: MediaSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 }\n  dragStartPosition: Point = { x: 0, y: 0 }\n  dragStartCrop: Point = { x: 0, y: 0 }\n  lastPinchDistance = 0\n  lastPinchRotation = 0\n  rafDragTimeout: number | null = null\n  rafPinchTimeout: number | null = null\n  wheelTimer: number | null = null\n\n  state: State = {\n    cropSize: null,\n    hasWheelJustStarted: false,\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.props.zoomWithScroll &&\n        this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n      this.containerRef.addEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.addEventListener('gesturechange', this.preventZoomSafari)\n    }\n\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = document.createElement('style')\n      this.styleRef.setAttribute('type', 'text/css')\n      this.styleRef.innerHTML = cssStyles\n      document.head.appendChild(this.styleRef)\n    }\n\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef && this.imageRef.complete) {\n      this.onMediaLoad()\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.removeEventListener('gesturechange', this.preventZoomSafari)\n    }\n\n    if (this.styleRef) {\n      this.styleRef.parentNode?.removeChild(this.styleRef)\n    }\n\n    this.cleanEvents()\n    this.props.zoomWithScroll && this.clearScrollEvent()\n  }\n\n  componentDidUpdate(prevProps: CropperProps) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes()\n      this.recomputeCropPosition()\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes()\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition()\n    } else if (\n      prevProps.cropSize?.height !== this.props.cropSize?.height ||\n      prevProps.cropSize?.width !== this.props.cropSize?.width\n    ) {\n      this.computeSizes()\n    } else if (\n      prevProps.crop?.x !== this.props.crop?.x ||\n      prevProps.crop?.y !== this.props.crop?.y\n    ) {\n      this.emitCropAreaChange()\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll\n        ? this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n        : this.clearScrollEvent()\n    }\n    if (prevProps.video !== this.props.video) {\n      this.videoRef?.load()\n    }\n  }\n\n  // this is to prevent Safari on iOS >= 10 to zoom the page\n  preventZoomSafari = (e: Event) => e.preventDefault()\n\n  cleanEvents = () => {\n    document.removeEventListener('mousemove', this.onMouseMove)\n    document.removeEventListener('mouseup', this.onDragStopped)\n    document.removeEventListener('touchmove', this.onTouchMove)\n    document.removeEventListener('touchend', this.onDragStopped)\n  }\n\n  clearScrollEvent = () => {\n    if (this.containerRef) this.containerRef.removeEventListener('wheel', this.onWheel)\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n  }\n\n  onMediaLoad = () => {\n    this.computeSizes()\n    this.emitCropData()\n    this.setInitialCrop()\n\n    if (this.props.onMediaLoaded) {\n      this.props.onMediaLoaded(this.mediaSize)\n    }\n  }\n\n  setInitialCrop = () => {\n    const { initialCroppedAreaPixels, cropSize } = this.props\n\n    if (!initialCroppedAreaPixels) {\n      return\n    }\n\n    const { crop, zoom } = getInitialCropFromCroppedAreaPixels(\n      initialCroppedAreaPixels,\n      this.mediaSize,\n      cropSize\n    )\n    this.props.onCropChange(crop)\n    this.props.onZoomChange && this.props.onZoomChange(zoom)\n  }\n\n  getAspect() {\n    const { cropSize, aspect } = this.props\n    if (cropSize) {\n      return cropSize.width / cropSize.height\n    }\n    return aspect\n  }\n\n  computeSizes = () => {\n    const mediaRef = this.imageRef || this.videoRef\n    if (mediaRef && this.containerRef) {\n      this.containerRect = this.containerRef.getBoundingClientRect()\n\n      this.mediaSize = {\n        width: mediaRef.offsetWidth,\n        height: mediaRef.offsetHeight,\n        naturalWidth: this.imageRef?.naturalWidth || this.videoRef?.videoWidth || 0,\n        naturalHeight: this.imageRef?.naturalHeight || this.videoRef?.videoHeight || 0,\n      }\n      const cropSize = this.props.cropSize\n        ? this.props.cropSize\n        : getCropSize(\n            mediaRef.offsetWidth,\n            mediaRef.offsetHeight,\n            this.containerRect.width,\n            this.containerRect.height,\n            this.props.aspect,\n            this.props.rotation\n          )\n\n      if (\n        this.state.cropSize?.height !== cropSize.height ||\n        this.state.cropSize?.width !== cropSize.width\n      ) {\n        this.props.onCropSizeChange && this.props.onCropSizeChange(cropSize)\n      }\n      this.setState({ cropSize }, this.recomputeCropPosition)\n    }\n  }\n\n  static getMousePoint = (e: MouseEvent | React.MouseEvent) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n  })\n\n  static getTouchPoint = (touch: Touch | React.Touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n  })\n\n  onMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    e.preventDefault()\n    document.addEventListener('mousemove', this.onMouseMove)\n    document.addEventListener('mouseup', this.onDragStopped)\n    this.onDragStart(Cropper.getMousePoint(e))\n  }\n\n  onMouseMove = (e: MouseEvent) => this.onDrag(Cropper.getMousePoint(e))\n\n  onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {\n    document.addEventListener('touchmove', this.onTouchMove, { passive: false }) // iOS 11 now defaults to passive: true\n    document.addEventListener('touchend', this.onDragStopped)\n    if (e.touches.length === 2) {\n      this.onPinchStart(e)\n    } else if (e.touches.length === 1) {\n      this.onDragStart(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault()\n    if (e.touches.length === 2) {\n      this.onPinchMove(e)\n    } else if (e.touches.length === 1) {\n      this.onDrag(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onDragStart = ({ x, y }: Point) => {\n    this.dragStartPosition = { x, y }\n    this.dragStartCrop = { ...this.props.crop }\n    this.props.onInteractionStart?.()\n  }\n\n  onDrag = ({ x, y }: Point) => {\n    if (this.rafDragTimeout) window.cancelAnimationFrame(this.rafDragTimeout)\n\n    this.rafDragTimeout = window.requestAnimationFrame(() => {\n      if (!this.state.cropSize) return\n      if (x === undefined || y === undefined) return\n      const offsetX = x - this.dragStartPosition.x\n      const offsetY = y - this.dragStartPosition.y\n      const requestedPosition = {\n        x: this.dragStartCrop.x + offsetX,\n        y: this.dragStartCrop.y + offsetY,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            this.props.zoom,\n            this.props.rotation\n          )\n        : requestedPosition\n      this.props.onCropChange(newPosition)\n    })\n  }\n\n  onDragStopped = () => {\n    this.cleanEvents()\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  onPinchStart(e: React.TouchEvent<HTMLDivElement>) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB)\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB)\n    this.onDragStart(getCenter(pointA, pointB))\n  }\n\n  onPinchMove(e: TouchEvent) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    const center = getCenter(pointA, pointB)\n    this.onDrag(center)\n\n    if (this.rafPinchTimeout) window.cancelAnimationFrame(this.rafPinchTimeout)\n    this.rafPinchTimeout = window.requestAnimationFrame(() => {\n      const distance = getDistanceBetweenPoints(pointA, pointB)\n      const newZoom = this.props.zoom * (distance / this.lastPinchDistance)\n      this.setNewZoom(newZoom, center)\n      this.lastPinchDistance = distance\n\n      const rotation = getRotationBetweenPoints(pointA, pointB)\n      const newRotation = this.props.rotation + (rotation - this.lastPinchRotation)\n      this.props.onRotationChange && this.props.onRotationChange(newRotation)\n      this.lastPinchRotation = rotation\n    })\n  }\n\n  onWheel = (e: WheelEvent) => {\n    e.preventDefault()\n    const point = Cropper.getMousePoint(e)\n    const { pixelY } = normalizeWheel(e)\n    const newZoom = this.props.zoom - (pixelY * this.props.zoomSpeed) / 200\n    this.setNewZoom(newZoom, point)\n\n    if (!this.state.hasWheelJustStarted) {\n      this.setState({ hasWheelJustStarted: true }, () => this.props.onInteractionStart?.())\n    }\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n    this.wheelTimer = window.setTimeout(\n      () => this.setState({ hasWheelJustStarted: false }, () => this.props.onInteractionEnd?.()),\n      250\n    )\n  }\n\n  getPointOnContainer = ({ x, y }: Point) => {\n    if (!this.containerRect) {\n      throw new Error('The Cropper is not mounted')\n    }\n    return {\n      x: this.containerRect.width / 2 - (x - this.containerRect.left),\n      y: this.containerRect.height / 2 - (y - this.containerRect.top),\n    }\n  }\n\n  getPointOnMedia = ({ x, y }: Point) => {\n    const { crop, zoom } = this.props\n    return {\n      x: (x + crop.x) / zoom,\n      y: (y + crop.y) / zoom,\n    }\n  }\n\n  setNewZoom = (zoom: number, point: Point) => {\n    if (!this.state.cropSize || !this.props.onZoomChange) return\n\n    const zoomPoint = this.getPointOnContainer(point)\n    const zoomTarget = this.getPointOnMedia(zoomPoint)\n    const newZoom = Math.min(this.props.maxZoom, Math.max(zoom, this.props.minZoom))\n    const requestedPosition = {\n      x: zoomTarget.x * newZoom - zoomPoint.x,\n      y: zoomTarget.y * newZoom - zoomPoint.y,\n    }\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          requestedPosition,\n          this.mediaSize,\n          this.state.cropSize,\n          newZoom,\n          this.props.rotation\n        )\n      : requestedPosition\n\n    this.props.onCropChange(newPosition)\n    this.props.onZoomChange(newZoom)\n  }\n\n  getCropData = () => {\n    if (!this.state.cropSize) {\n      return null\n    }\n\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ricardo-ch/react-easy-crop/issues/6)\n    const restrictedPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    return computeCroppedArea(\n      restrictedPosition,\n      this.mediaSize,\n      this.state.cropSize,\n      this.getAspect(),\n      this.props.zoom,\n      this.props.rotation,\n      this.props.restrictPosition\n    )\n  }\n\n  emitCropData = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropComplete) {\n      this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels)\n    }\n\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  emitCropAreaChange = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  recomputeCropPosition = () => {\n    if (!this.state.cropSize) return\n\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    this.props.onCropChange(newPosition)\n    this.emitCropData()\n  }\n\n  render() {\n    const {\n      image,\n      video,\n      mediaProps,\n      transform,\n      crop: { x, y },\n      rotation,\n      zoom,\n      cropShape,\n      showGrid,\n      style: { containerStyle, cropAreaStyle, mediaStyle },\n      classes: { containerClassName, cropAreaClassName, mediaClassName },\n      objectFit,\n    } = this.props\n\n    return (\n      <div\n        onMouseDown={this.onMouseDown}\n        onTouchStart={this.onTouchStart}\n        ref={(el) => (this.containerRef = el)}\n        data-testid=\"container\"\n        style={containerStyle}\n        className={classNames('reactEasyCrop_Container', containerClassName)}\n      >\n        {image ? (\n          <img\n            alt=\"\"\n            className={classNames(\n              'reactEasyCrop_Image',\n              objectFit === 'contain' && 'reactEasyCrop_Contain',\n              objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n              objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n              mediaClassName\n            )}\n            {...(mediaProps as React.ImgHTMLAttributes<HTMLElement>)}\n            src={image}\n            ref={(el: HTMLImageElement) => (this.imageRef = el)}\n            style={{\n              ...mediaStyle,\n              transform:\n                transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n            }}\n            onLoad={this.onMediaLoad}\n          />\n        ) : (\n          video && (\n            <video\n              autoPlay\n              loop\n              muted={true}\n              className={classNames(\n                'reactEasyCrop_Video',\n                objectFit === 'contain' && 'reactEasyCrop_Contain',\n                objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n                objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n                mediaClassName\n              )}\n              {...mediaProps}\n              ref={(el: HTMLVideoElement) => (this.videoRef = el)}\n              onLoadedMetadata={this.onMediaLoad}\n              style={{\n                ...mediaStyle,\n                transform:\n                  transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n              }}\n              controls={false}\n            >\n              {(Array.isArray(video) ? video : [{ src: video }]).map((item) => (\n                <source key={item.src} {...item} />\n              ))}\n            </video>\n          )\n        )}\n        {this.state.cropSize && (\n          <div\n            style={{\n              ...cropAreaStyle,\n              width: this.state.cropSize.width,\n              height: this.state.cropSize.height,\n            }}\n            data-testid=\"cropper\"\n            className={classNames(\n              'reactEasyCrop_CropArea',\n              cropShape === 'round' && 'reactEasyCrop_CropAreaRound',\n              showGrid && 'reactEasyCrop_CropAreaGrid',\n              cropAreaClassName\n            )}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nexport default Cropper\n"],"names":["getCropSize","mediaWidth","mediaHeight","containerWidth","containerHeight","aspect","rotation","_a","translateSize","width","height","fittingWidth","Math","min","fittingHeight","restrictPosition","position","mediaSize","cropSize","zoom","x","restrictPositionCoord","y","maxPosition","max","getDistanceBetweenPoints","pointA","pointB","sqrt","pow","getRotationBetweenPoints","atan2","PI","computeCroppedArea","crop","limitAreaFn","limitArea","noOp","croppedAreaPercentages","widthInPixels","round","naturalWidth","heightInPixels","naturalHeight","sizePixels","croppedAreaPixels","value","_max","getInitialCropFromCroppedAreaPixels","mediaZoom","getZoomFromCroppedAreaPixels","cropZoom","getCenter","a","b","rotateAroundMidPoint","xMid","yMid","degrees","cos","sin","radian","centerX","centerY","outerBounds","minX","map","p","maxX","minY","classNames","_i","args","filter","length","join","trim","_this","hasWheelJustStarted","e","preventDefault","document","removeEventListener","onMouseMove","onDragStopped","onTouchMove","containerRef","onWheel","wheelTimer","clearTimeout","computeSizes","emitCropData","setInitialCrop","props","onMediaLoaded","initialCroppedAreaPixels","_b","onCropChange","onZoomChange","mediaRef","imageRef","videoRef","containerRect","getBoundingClientRect","offsetWidth","offsetHeight","videoWidth","videoHeight","state","onCropSizeChange","setState","recomputeCropPosition","addEventListener","onDragStart","Cropper","getMousePoint","onDrag","passive","touches","onPinchStart","getTouchPoint","onPinchMove","dragStartPosition","dragStartCrop","onInteractionStart","rafDragTimeout","window","cancelAnimationFrame","requestAnimationFrame","undefined","offsetX","offsetY","requestedPosition","newPosition","cleanEvents","onInteractionEnd","point","pixelY","normalizeWheel","newZoom","zoomSpeed","setNewZoom","setTimeout","Error","left","top","zoomPoint","getPointOnContainer","zoomTarget","getPointOnMedia","maxZoom","minZoom","getAspect","cropData","getCropData","onCropComplete","onCropAreaChange","__extends","this","zoomWithScroll","preventZoomSafari","disableAutomaticStylesInjection","styleRef","createElement","setAttribute","innerHTML","head","appendChild","complete","onMediaLoad","parentNode","removeChild","clearScrollEvent","prevProps","emitCropAreaChange","video","load","lastPinchDistance","lastPinchRotation","center","rafPinchTimeout","distance","newRotation","onRotationChange","image","mediaProps","transform","cropShape","showGrid","_c","containerStyle","cropAreaStyle","mediaStyle","_d","containerClassName","cropAreaClassName","mediaClassName","objectFit","React","onMouseDown","onTouchStart","ref","el","style","className","alt","src","onLoad","autoPlay","loop","muted","onLoadedMetadata","controls","Array","isArray","item","key","classes","Number","clientX","clientY","touch","Component"],"mappings":"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"}